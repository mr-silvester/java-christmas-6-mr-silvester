# 🔍About Context

```christmas.context``` 패키지는 스프링 프레임워크의 핵심 개념을 모방하여 작성되었습니다.
패키지 내의 클래스를 스캔하고, 그 클래스들에 특정 어노테이션들을 확인하여, 이들을 빈(bean)이라는 개념으로 등록하고 관리합니다.
이 빈들은 애플리케이션에서 필요한 다양한 부분들을 표현합니다. ```ApplicationContext``` 는 이들을 찾아주고 필요한 경우 인스턴스를 생성하여 제공합니다.
또한 빈들 간의 의존성을 해결하고, **지연 로딩(Lazy loading)** 또는 **즉시 로딩(Eager loading)** 과 같은 성능 최적화 옵션을 제공합니다.

## 🧰 구동 방식 
```ApplicationContext```은 빈을 이름과 인스턴스로 등록하고 조회하는 기능을 가진 ```BeanFactory```와
빈이 구현 또는 상속하고 있는 인터페이스(interface)나 상위 클래스(superclass)에 대한 매핑 정보를 저장하는
```TypedBeanRegistry``` 를 상속하는 인터페이스입니다. ```ApplicationContext```는 빈을 등록하고 조회하는 기능뿐만 아니라
매핑된 빈의 인터페이스나 상위 클래스의 정보를 통해 다형성을 이용한 의존성 주입에 유연함을 가집니다.

```ApplicationContext```는 다음과 같은 절차로 빈을 생성과 주입을 관리합니다.

### 📮 빈 타입 등록

1. 초기화 시점에 ```AnnotatedClassScanner```를 통해 패키지 내의 ```@Scan``` 애노테이션이 적용된 class 타입을 List 형식으로 획득합니다. ```@Component``` 또한 ```@Scan```을 포함하므로 스캔 대상이 됩니다.
2. ```@Scan```이 적용된 class 타입 중 ```@Component``` 애노테이션이 적용된 class 타입만을 필터링하고 해당 class 타입이 인터페이스의 구현체 또는 상속 클래스라면 그 정보를 ```HashMap```으로 이루어진 ```registry```에 저장합니다. 

```ApplicationContext```는 아래와 같은 흐름을 통해 추상화와 구체화의 연관관계를 알 수 있습니다.
```
<인터페이스 타입(또는 상위 클래스 타입), 구현체 타입> ↔ <구현체 타입, 빈 이름> ↔ <빈 이름, 실제 인스턴스>
```

### 🔧 빈 생성
3. 1에서 획득한 class 타입 List 에서 ```@Component```가 적용된 클래스들의 인스턴스를 생성하여 빈으로 등록합니다. 이때, 해당 클래스의 생성자를 분석하고 인자로 필요한 빈이 있다면 ```registry```를 조회하여 매핑된 실제 타입의 빈을 찾아 주입합니다.
4. 만약 찾고자하는 빈이 ```registry```에 정의 되어있지만 생성이 되어있지 않다면 새로 생성한 후 주입합니다. ```registry```에도 등록되어있지 않다면 예외를 발생시킵니다.

- ApplicationContext 의 전략이 즉시 로딩(기본값)이라면 초기화시점에 모든 빈을 생성하고, 지연 로딩이라면 호출된 시점에 빈을 생성합니다.